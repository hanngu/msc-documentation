\section{Evaluation}
\label{sec:algoEvaluation}
After each ant in the SuperSwarm colony has created a complete route set, the ants are evaluated. The results of the evaluation determines which routes that are granted extra pheromone and which ants to be followed in the next iteration. In addition the best ant so far is updated, if the given iteration has produced an ant with a better total fit. In this evaluation, the route sets are evaluated as a whole, because the connectivity and the paths chosen are dependent of the entire route set. 

\subsection{Removing of ants that did not fulfill the constraints}
The first step of evaluation is the removal of ants that have generated route sets which corresponds to a disconnected graph. This is because constraint \vref{itm:criteriaConnectedGraph} states that a passenger should be able to travel from every node to every other node within the route set. For an undirected graph $G$ to be classified as connected, there must be a path between every pair of nodes. 

\subsection{Calculating Total Fit}
After the removal of ants that did not satisfy the constraint mentioned above, the Total Fit $TOTFIT(r)$ for the route sets of the remaining ants are calculated. The calculation of $TOTFIT(r)$ for route set $r$ is inspired by \citep{kechagiopoulos14} and is described as the sum $F_{1}(r)$, $F_{2}(r)$ and $F_{3}(r)$: 
\newline
$$ TOTFIT(r) = F_{1}(r) + F_{2}(r) + F_{3}(r)$$
\newline
$F_{1}(r)$ is related to the total travel time for each passenger in the network. The demands described in Table \vref{tbl:mandlDemand} corresponds to how many passengers that travels between each node couple $[i,j]$ each day. $F_{1}(r)$ is the sum of the difference between the shortest path possible given the route set, $sp_r$, and the shortest path possible in the network, $sp_n$, for every passenger $p$:
\newline
$$F_{1}(r) = \sum\limits^{p}_{p=1}sp_r-sp_n$$
\newline
Both $sp_r$ and $sp_n$ are calculated using the built-in Dijkstra algorithm in Neo4j. Dijkstra's algorithm \cite[p.658-662]{cormen09} maintains a set $S$ of vertices's whose final shortest-path weights from the source $s$ have already been determined. The algorithm repeatedly selects the vertex $u = V - S$ with the minimum shortest path estimate, adds $u$ to $S$, and relaxes\footnote{Making a change that reduces constraints.} all edges leaving $u$. The running time of Dijkstra's algorithm is $O((V + E)lg V)$ and it is guaranteed to find the shortest path.\cite[p.~661]{cormen09}. In \citep{mandl79}, the author proposes two different methods for calculating the shortest path between to nodes in a transit network, given a specific route set. \texit{Method 1} chooses the path with the shortest traveling time, not considering transfer penalties. \texit{Method 2} chooses the path with shortest traveling time, including the transfer penalties. To achieve the most accurate and realistic results this method uses \textit{Method 2}. This gives us the following equation for calculating the travel time $TT$ between two nodes: 
\newline
$$TT = IVT + (\Gamma*NT)$$
\newline
Where $IVT$ is the in-vehicle time, $\Gamma$ is the transfer penalty and $NT$ is the number of transfers. For comparison reasons $\Gamma$ is set to 5 minutes. 

\subsection{Calculating $F_{1}(r)$}

This score is obtained by evaluating how good the path between two nodes, $k_1$ and $k_2$, in the route set is. The score is calculated by finding the difference ($DIF$) in travel time between the edges included in the route set, and the actual minimum travel time (shortest path):

$$ DIF = TT(k_{1},k_{2}) - MTT(k_{1},k_{2})$$

where $ TT(k_{1},k_{2})$ is the travel time using the edges included in the route set, and $ MTT(k_{1},k_{2})$ is the actual minimum travel time (shortest path) between the two nodes, regardless of the edges included in the route set. Calculating the minimum travel time (shortest path) is done by Neo4j, and the selection of which algorithm used is described under.

\subsubsection{Calculating Minimum Travel Time}

Neo4j includes two built-in algorithms for finding the shortest path, including A* search\citep{russel10}  and Dijkstra's algorithm\citep{cormen09}. 

A* search\cite[p.93-94]{russel10} evaluates nodes by combining $g(n)$, the cost to reach the node, and $h(n)$, the cost to get from the node to the goal.

$$ f(n) = g(n) + h(n).$$
Since g(n) gives the path cost from the start node to node $n$, and $h(n)$ is the estimated cost of the cheapest path from $n$ to the goal, we have
$$f(n) = \text{estimated cost of the cheapest solution through $n$} $$ 

A* search is both optimal and complete, provided that $h(n)$ is admissible\footnote{It never overestimates the cost to reach the goal.} or consistent\footnote{When estimating the distance of a given state to a goal state, it is always at most equal to the estimated distance from any neighboring vertex plus the step cost of reaching that neighbor.}. 

$$ \text{A* search running time: } O(E) = O(b^d)$$
\textit{where $b$ is the branching factor (average number of successors per state)}

Dijkstra's algorithm \cite[p.658-662]{cormen09} maintains a set $S$ of vertices's whose final shortest-path weights from the source $s$ have already been determined. The algorithm repeatedly selects the vertex $u = V - S$ with the minimum shortest path estimate, adds $u$ to $S$, and relaxes\footnote{Making a change that reduces constraints.} all edges leaving $u$.

Dijkstra's algorithm is guaranteed to find the shortest path\cite[p.~661]{cormen09}.
$$\text{Dijkstra's algorithm running time: } O((V + E)lg V)$$

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|l|l|l|}
      \hline
      ~ & A* search & Dijkstra's algorithm\\
      \hline
        MIN & 291 & 569 \\
        AVG & 328 & 589 \\
        MAX & 301 & 610 \\
      \hline
        \end{tabular}
    \end{center}
    \caption {A* Search vs. Dijkstra's algorithm}
    \label{table:astarvsdijkstras}
\end{table}

Table \ref{table:astarvsdijkstras} presents the running times for the different algorithms, in seconds, after 20 runs, with 100 iterations, 100 ants, 4 routes,  and max 8 nodes in each route. Observations shows that A* search is faster, \emph{\color{red} because blabla}, and this method is therefore chosen for finding the shortest path in $F_1(r)$.
 
% In other words, it reflects the average time spent by each passenger when traveling along a specific route set. Its value is small if the respective average traveling time is big and big is traveling time is small. In order to estimate F1(r), not only the average traveling time has to be calculated, but one also determine whether this value should be considered big or small. 

\subsection{Calculating $F_{2}(r)$}
%TODO: skrive om dette
$F_{2}(r)$ score reflects the percentage of passengers traveling from their origin to their destination either directly, making a single transfer, or transferring twice. Calculating $F_{2}$ is done using the following equation \emph{\color{red} -  kechapocholus har gjort noe mer her, sjekk ut dette..}:
$$F_2(r) = 3xd_0(r)+ 2xd_1(r)+ xd_2(r) $$

where  $d_0(r)$ is the percentage of passengers traveling directly, $d_1(r)$ is the percentage of passengers traveling from their origin to their destination making a single transfer, and $d_2(r)$ is the percentage of passengers traveling from their origin to their destination transferring twice. \emph{\color{red}$x=-1$, and represents? Her må det forklares hvorfor $d_0$ ganges med et høyere tall osv.}. The reason the number is negative is \emph{\color{red}coding reasons. } 

%\begin{itemize}
%\item it checks for the node couple in a route, if the route contains both the nodes, then it is a direct traveler
%\item it checks if the node couple is withing 2 routes
%\item it checks if the the node couple is withing 3 routes
%\end{itemize}

%$f_2(r) = (-3) * directCouples + (-2) * oneTransferCouples + (-1) * twoTransferCouples $

\subsection{Calculating $F_3(r)$}
%TODO: skrive om dette
$F_3(r)$ is a score which reflects the percentage of unsatisfied passengers, meaning passengers traveling from their origin to their destination where the number of transfers is more than 3, using route set $r$. It is calculated using the following formula:
$$\emph{\color{red}hannee?}$$

\begin{itemize}
\item[Step 5] 50\% of the best ants are added to the final best ants set.
\item[Step 6] The algorithm awards sets that satisfy node couples with high demand directly. Demand value to consideration.
\item[Step 7] Reward the edges in these routes by giving them more pheromone, and is given by:

$$ \tau_{ij} = \sum_{k=1}^{m} \Delta \tau^k_{ij}$$

where $ \Delta \tau^k_{ij} $ is the amount of pheromone laid on route (i,j) by the $k^{th}$ ant and is given by

$$
\Delta \tau^k_{ij} = \Bigg\{
\begin{array}{l l}
\underline{P_{b}} &  \quad \text{if route (i,j) be traversed by}\\
f_k, &  \quad \text{the $k^{th}$ ant (at the current cycle) , }\\
0 &  \quad \text{otherwise}
\end{array}
$$

$p_b$ is a value determined in the parameter setting experiments, and $f_k$ is the travel time on the edge.

\end{itemize}

\section{Pheromone Evaporation}

The pheromone on each edge decrease by $p\%$ after each iteration. 