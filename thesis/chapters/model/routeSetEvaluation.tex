\section{Evaluation}
\label{sec:algoEvaluation}
After each ant in the SuperSwarm colony has created a complete route set, the ants are evaluated. The results of the evaluation determines which routes that are granted extra pheromone and which ants to be followed in the next iteration. In addition the best ant so far is updated, if the given iteration has produced an ant with a better total fit. In this evaluation, the route sets are evaluated as a whole, because the connectivity and the paths chosen are dependent of the entire route set. The evaluation is conducted in x steps:
\begin{itemize}
\item[Step 1] Ants that have generated route sets which corresponds to a disconnected graph are removed from the set of ants to be evaluated. This is because constraint \vref{itm:criteriaConnectedGraph} states that a passenger should be able to travel from every node to every other node within the route set. For an undirected graph $G$ to be classified as connected, there must be a path between every pair of nodes. 

\item[Step 2] 

\item [Step 3]\label{itm:TOTFIT} The route sets are added to the Neo4J database, and evaluated by a fitness function, TOTFIT(r), where $r$ is the route set, inspired by \citep{kechagiopoulos14}.
This fitness value is calculated as follows:
$$ TOTFIT(r) = F_{1}(r) + F_{2}(r) + F_{3}(r), $$

where $ F_{1}(r)$ is the score obtained by evaluating the route set by the total in-vehicle time, $ F_{2}(r)$ is the score obtained by evaluating the route set using evaluation criteria direct traveler, one transfer, two transfers, and $ F_{3}(r)$ is the score obtained by evaluating the route set using the criteria unsatisfied customers (more than two transfers). 
%$ w_{1}, w_{2}$, and$ w_{3}$ are user specified weights for scores $ F_{1}(r), F_{2}(r),$ and $ F_{3}(r)$, respectively. 
%To find w, we will calculate an average with ratio, and give weights from that, and theese weights sum is 1.  
\end{itemize}

\subsection{Calculating $F_{1}(r)$}

This score is obtained by evaluating how good the path between two nodes, $k_1$ and $k_2$, in the route set is. The score is calculated by finding the difference ($DIF$) in travel time between the edges included in the route set, and the actual minimum travel time (shortest path):

$$ DIF = TT(k_{1},k_{2}) - MTT(k_{1},k_{2})$$

where $ TT(k_{1},k_{2})$ is the travel time using the edges included in the route set, and $ MTT(k_{1},k_{2})$ is the actual minimum travel time (shortest path) between the two nodes, regardless of the edges included in the route set. Calculating the minimum travel time (shortest path) is done by Neo4j, and the selection of which algorithm used is described under.

\subsubsection{Calculating Minimum Travel Time}

Neo4j includes two built-in algorithms for finding the shortest path, including A* search\citep{russel10}  and Dijkstra's algorithm\citep{cormen09}. 

A* search\cite[p.93-94]{russel10} evaluates nodes by combining $g(n)$, the cost to reach the node, and $h(n)$, the cost to get from the node to the goal.

$$ f(n) = g(n) + h(n).$$
Since g(n) gives the path cost from the start node to node $n$, and $h(n)$ is the estimated cost of the cheapest path from $n$ to the goal, we have
$$f(n) = \text{estimated cost of the cheapest solution through $n$} $$ 

A* search is both optimal and complete, provided that $h(n)$ is admissible\footnote{It never overestimates the cost to reach the goal.} or consistent\footnote{When estimating the distance of a given state to a goal state, it is always at most equal to the estimated distance from any neighboring vertex plus the step cost of reaching that neighbor.}. 

$$ \text{A* search running time: } O(E) = O(b^d)$$
\textit{where $b$ is the branching factor (average number of successors per state)}

Dijkstra's algorithm \cite[p.658-662]{cormen09} maintains a set $S$ of vertices's whose final shortest-path weights from the source $s$ have already been determined. The algorithm repeatedly selects the vertex $u = V - S$ with the minimum shortest path estimate, adds $u$ to $S$, and relaxes\footnote{Making a change that reduces constraints.} all edges leaving $u$.

Dijkstra's algorithm is guaranteed to find the shortest path\cite[p.~661]{cormen09}.
$$\text{Dijkstra's algorithm running time: } O((V + E)lg V)$$

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|l|l|l|}
      \hline
      ~ & A* search & Dijkstra's algorithm\\
      \hline
        MIN & 291 & 569 \\
        AVG & 328 & 589 \\
        MAX & 301 & 610 \\
      \hline
        \end{tabular}
    \end{center}
    \caption {A* Search vs. Dijkstra's algorithm}
    \label{table:astarvsdijkstras}
\end{table}

Table \ref{table:astarvsdijkstras} presents the running times for the different algorithms, in seconds, after 20 runs, with 100 iterations, 100 ants, 4 routes,  and max 8 nodes in each route. Observations shows that A* search is faster, \emph{\color{red} because blabla}, and this method is therefore chosen for finding the shortest path in $F_1(r)$.
 
% In other words, it reflects the average time spent by each passenger when traveling along a specific route set. Its value is small if the respective average traveling time is big and big is traveling time is small. In order to estimate F1(r), not only the average traveling time has to be calculated, but one also determine whether this value should be considered big or small. 

\subsection{Calculating $F_{2}(r)$}
%TODO: skrive om dette
$F_{2}(r)$ score reflects the percentage of passengers traveling from their origin to their destination either directly, making a single transfer, or transferring twice. Calculating $F_{2}$ is done using the following equation \emph{\color{red} -  kechapocholus har gjort noe mer her, sjekk ut dette..}:
$$F_2(r) = 3xd_0(r)+ 2xd_1(r)+ xd_2(r) $$

where  $d_0(r)$ is the percentage of passengers traveling directly, $d_1(r)$ is the percentage of passengers traveling from their origin to their destination making a single transfer, and $d_2(r)$ is the percentage of passengers traveling from their origin to their destination transferring twice. \emph{\color{red}$x=-1$, and represents? Her må det forklares hvorfor $d_0$ ganges med et høyere tall osv.}. The reason the number is negative is \emph{\color{red}coding reasons. } 

%\begin{itemize}
%\item it checks for the node couple in a route, if the route contains both the nodes, then it is a direct traveler
%\item it checks if the node couple is withing 2 routes
%\item it checks if the the node couple is withing 3 routes
%\end{itemize}

%$f_2(r) = (-3) * directCouples + (-2) * oneTransferCouples + (-1) * twoTransferCouples $

\subsection{Calculating $F_3(r)$}
%TODO: skrive om dette
$F_3(r)$ is a score which reflects the percentage of unsatisfied passengers, meaning passengers traveling from their origin to their destination where the number of transfers is more than 3, using route set $r$. It is calculated using the following formula:
$$\emph{\color{red}hannee?}$$

\begin{itemize}
\item[Step 5] 50\% of the best ants are added to the final best ants set.
\item[Step 6] The algorithm awards sets that satisfy node couples with high demand directly. Demand value to consideration.
\item[Step 7] Reward the edges in these routes by giving them more pheromone, and is given by:

$$ \tau_{ij} = \sum_{k=1}^{m} \Delta \tau^k_{ij}$$

where $ \Delta \tau^k_{ij} $ is the amount of pheromone laid on route (i,j) by the $k^{th}$ ant and is given by

$$
\Delta \tau^k_{ij} = \Bigg\{
\begin{array}{l l}
\underline{P_{b}} &  \quad \text{if route (i,j) be traversed by}\\
f_k, &  \quad \text{the $k^{th}$ ant (at the current cycle) , }\\
0 &  \quad \text{otherwise}
\end{array}
$$

$p_b$ is a value determined in the parameter setting experiments, and $f_k$ is the travel time on the edge.

\end{itemize}

\section{Pheromone Evaporation}

The pheromone on each edge decrease by $p\%$ after each iteration. 