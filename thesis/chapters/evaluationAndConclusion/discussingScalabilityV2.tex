
%Discuss what you managed, and why you had sucess / not success. Show that you understand. In the discussion it is important to include a discussion of not just the merits of the work conducted but also the limitations.
%Svar på research questionsene. %Hva har vi fått til? Hva har vi ikke fått til? Hvorfor fikk vi det til? Hvorfor fikk vi det ikke til? (Små endringer som faktisk kunne blitt gjort, må ikke nevnes, betyr bare at vi har begynt sent på oppgaven.)

\subsection{Is it possible to apply the proposed system to optimize urban transit routes in real urban cities?}

The proposed system as-is will not be possible to use for optimizing the urban transit routes in a real urban city. This is because with the current implementation of Neo4j, the system exceeds the address space for the primary key RelationshipType when either the swarm size, the number of iterations or the number of routes in a route set becomes to big compared to the network size. 

As an example consists Trondheim city, which is the forth largest city in Norway, of 33 bus routes \cite{website:atb-linjenett}. If we were to use the current solution, including the selected parameters for the swarm size and iteration number, as described in Section \vref{subsec:parameterSettings_results} the number of relationship types created would be $125 (number of iterations) * 50 (the swarm size) * 33 (bus routes) = 206 250$. The reader recalls from Section \vref{subsec:evalScalability} that the current number of allowed RelationshipTypes in Neo4j is approximately $66 000$.
\emph{\color{blue} Sjekk opp antall bussruter med AtB}.

The system would be applicable to urban cities if the number of generated RelationshipTypes were increased. This can be done by creating the routes as effectively the same RelationshipType, but in order to separate them, add properties, such as ant number and iteration number, to the generated Relationships instead. This solution would, however, lead to not being able to use the built-in shortest path algorithms, such as Dijkstra. This is because they require to choose paths based RelationshipType. Therefore, if one were to change the way different routes were represented in Neo4j, on would also need to implement a separate shortest path algorithm. 

However, even if the number of RelationshipTypes were reduced, there is an other drawback that makes our solution unpractical to use: The large difference in run time between using Method 1 and Method 2 when evaluating the route sets. 
The reader recalls that we in Section \vref{subsec:scalabilityExperiments_setup} indicate that Method 2 gives a better Total Fitness than Method 1, but that the runtime is more than ten times larger compared to using Method 1. These results are also supported by the research of \citet{fan09}. Nevertheless, generating bus routes is an infrequent task in most urban cities and a because of this we believe that a long run time could be acceptable, given that the system creates a better solution than the one that already exists. 

A requirement that must be fulfilled for our system to be applicable is files containing average number of demand between every two nodes/bus stops, travel times between nodes/bus stops and a list of all the nodes/bus stops in the network, similar to the ones provided by \citet{mandl79} and \citet{mumford13}. This data can typically be obtained by the bus companies.

\subsection{What are the potential advantages and disadvantages of using a graph database in our implementation?}

The graph database Neo4j has several advantages for our implementation. Firstly, Neo4j represent data in a graph way, with nodes and relationship between the nodes. In addition it has the capability of traversing the graph, by following pointers from each node. This corresponds perfectly to our data model, which consist of exclusively objects that can be represented as relationships or nodes. Secondly, it offers an embedded version, which makes it possible to run Neo4j embedded in the Java program. This leads to, as mentioned in {\color{blue} [Skrive inn Section når vi vet hvor dette blir skrevet. Mest sannsynlig i Model]}, a lower latency of the many reads and writes executed when running the algorithm, compared to using a standalone version. Thirdly we do believe the use of Neo4j made our development process smoother and less excessive. This because we were able to benefit from Neo4j features such as the built-in Djikstra algorithm and the possibility to inspect the object graph. Finally, Neo4j is a well-documented and battle-tested graph database system, implemented and used by large companies such as Telenor\cite{website:telenor}, Walmart\cite{website:walmart} and Cisco\cite{website:cisco}. This made it easy for us to retrieve relevant information during the development process and have confidence in the product. 

However, Neo4j also has some disadvantages concerning our implementation. The first one is, as mentioned in Section \vref{subsec:evalScalability}, that the limit of RelationshipTypes is insufficient in our system. This leads to, as mentioned, that we are not able to run the algorithm on larger networks than the Mandl network, without making sacrifices that influence the performance. Secondly, we suspect that the run time of the algorithm would have been improved by removing Neo4j or by least changing the data model. With the current data model, each generated edge in each generated route for each ant for each generated iteration is represented as a relationship {\color{blue} [Vi bør egentlig lage en illustrasjon av datamodellen for å bedre forklare hvordan dataene blir lagret --> Model]}. For the smallest network with the least number of routes tested in this thesis, this still adds up to about 200000 relationships when the swarm size is 50 and the number of iterations is 125. Additionally, by using a database the algorithm executes both read and write operations to disk. It is likely to believe that the run time could have been improved by creating a system using only the Random Access Memory.  

%to find the optimal route between two nodes in a network. It contains a list of all routes between two nodes, and find the most optimal path concerning the cost. A suited query is where you will be looking to find out how different data element are related to each other, finding paths between different nodes on the graph. All you have to do is apply algorithm with start node and end node. (And it can see whether a path exist and finding the optimal path). 

%Neo4j is optimized for multi relational graph, which means graphs with multiple relationship between nodes. It is worth mentioning, that the work relationship is equivalent to an edge. Neo4j comes with different features, including relationship types. Which is added to the relationships and every relationship must have exactly one type - these relationship types is used to traverse a specific query. Neo4j supports complex queries, because it can hop from node to node over its connected relationships. The key performance that follows from this is that performance is independent of the data set size, because in most graphs everything is not connected to everything. Performance will be much more dependent on the size of the result set (How many results a query gives).  \emph{\color{blue} TODO: hvor stort blir resultat settet }

%\textbf{What are the limitations?}\textbf{Do you understand why it work and doesn't work?}
%* Dumb with our solution: we have made a lot of relationship types.
%* However, this results in an enormous amount of relationships and relationship types. Neo4j has a capacity of 1216, which with solution it exceeds when the size of the route sets increase. We experienced, as mentioned over, that Neo4j has a id capacity which is reached when the route sets become greater than 10. This is not very optimal when creating routes in a large transit network. Instead of having a relationship type edge and added properties on these, each individual route for ant for each iteration, receive a relationship type. This makes it possible to separate each individual route for each ant. This makes each route in each route set saved with an unique identifier. A feature that could have been used is the property feature, which can add properties to a relationship. And these properties can be used to evaluate the pattern we are looking for. As stated in \citet{bruggen14}, assigning relationship types between nodes is recommended. This is because the cost of introducing a new relationship between two nodes is very low. Because no additional joins needs to be computed, all that happens is that the graph traversal will use a different path when establishing a course. The use of properties \emph{\color{blue} TODO. undersøke hvordan properties fungerer. evt droppe å nevne det mtp på at sensor mest sanns ikke gidder å lese seg opp på neo4j}

%* [sjekkes opp først] Negative of graph databases: Searching for a specific node, have to search (worst case) trough all nodes. 
%* This also concerns es the relationship types. This is where the bottleneck lies. 

%\textbf{\color{blue} Til diskusjon:}

%The parameters tested and used are specifically tuned for Mandl's Transit Network containing 4 routes, with maximum 8 nodes in one route, but the same parameters are used when testing with 6, 7, and 8 routes as well. This may be considered a weakness, because metaherustic methods, such as the one proposed in this thesis, requires calibration of parameters with respect to the problem at hand \citep{dobslaw09}.

%The proposed method requires input on a particular form. Both nodes and their coordinates, travel time between nodes and the demand between nodes needs to be provided on a particular form in an .txt-document. This may be considered as a weakness of the method, but implementing support for retrieving the mentioned data on another form are considered as fairly easy.

