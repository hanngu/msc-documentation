\subsection{Network Expansion}
\label{subsec:networkExpansion}


Observing the results found in Table \vref{table:mumford0_and1_results}, one can see that the experiments using the  instances Mumford0 and Mumford1 were ran with a value of the parameter $i$ sat to 50. This is done because with original value, neither the experiments on Mumford0 or Mumford1 were able to produce any results. The reason for this is that the number of generated RelationshipTypes becomes higher than the limit of allowed RelationshipTypes sat by Neo4j. Compared to the Mandl network have all of the Mumford-instances an increased number of routes in the route sets ($NRS$). The reader recalls from Section \vref{subsec:networkGeneration} that for each route in each ant's route set for each iteration a new RelationshipType is created. The number of RelationshipTypes ($NRT$) is therefore dependent on both the number ants, the number of iterations and the $NRS$. Neo4j has a limit of $2^{16} = 65 536$ RelationshipTypes. As demonstrated in Table \vref{tabel:numberOfRelationshipTypes}, neither of the Mumford-instances is within this limit with the original value of $i$ and the given $NRS$. However, by reducing $i$ to 50, both Mumford0 and Mumford1 will be within the limit. The reader recalls from Section \vref{subsec:parameterSettings_results} that the higher the $i$, the better the result. Due to the reduction of $i$, we therefore believe the results of the experiments run on the Mumford0 and Mumford1 networks have suffered. To be able to run experiments on Mumford2 or Mumford3, either $s$ or $i$ had to be further reduced. Because further reduction of either of these parameters would lead to a further deterioration of the results, this was not done.

\emph{\color{blue} Motivation må oppdateres}. As stated in the motivation we wanted to explore how the usage of Neo4j would affect our proposed solution, and in order to this we chose to include multiple artifacts from Neo4j. This included using the built-in Dijkstra method in Neo4j. The built-in Dikjstra is able to find both the overall shortest path and all paths between two nodes, and it also includes a possibility of finding the shortest path given one or more RelationshipType. This made it possible for use it when evaluating the different route sets created by different ants. 
By using the built-in Dijkstra we believe the development time was reduced, and for relatively small networks it is sufficient. However, as we can see from the results, the built-in Dijkstra is not suited for usage when the networks becomes larger than the Mandl Network, because of the increased number of RelationshipTypes created.

Comparing the results produced by the proposed algorithm on the Mumford0 and Mumford1 networks to the results produced on the Mandl network, found in Table \vref{table:performanceComparison_routesets}, one can see that the average number of direct travelers ($d_0$) decreases, and the number of unsatisfied passengers ($d_{unsat}$) increases. 

This could, as mentioned above, be linked to the reduction of $i$. This reduction results in that the experiments ran on the Mumford networks, which are in fact twice or more the size of the Mandl network, are explored by 3750 less ants in total. This leads to a smaller probability of finding the best route sets.

Another reason for this is, as mentioned in Section \vref{subsec:scalabilityExperiments_setup}, that Method 1 is used when deciding which route a passenger should use, where Method 2 is used for the experiments ran on the Mandl Network. In Method 1 the transfer penalties are not considered when choosing a path, which leads to possibly choosing paths with many transfers. This again leads to a higher number of unsatisfied travelers, and a lower number of direct travelers compared to using Method 2. Further it leads to a higher average travel time, due to the fact that transfer penalties is added to the total travel time afterwards. 

%Another reason is that when testing the Mumford Networks, 50 iterations is used compared to 125 when testing the Mandl Network. This results in that the Mumford networks, which are in fact twice or more the size of the Mandl network, are explored by 3750 less ants in total and thus have a smaller probability of finding the best route sets. The reason for this is that each route of each ant in a given iteration has its own relationship type, and the number of routes in a route set ($NRS$) is larger in the Mumford Networks. Due to the fact that Neo4j has a limit of $2^{16} \approx 66 000$ relationship types, as demonstrated in \vref{tabel:numberOfRelationshipTypes}, the number of relationship types, $NRT$, would exceed Neo4j's capacity. 

\begin{table}[H]
    \centering
    \hspace*{-1.0cm}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{$NRS$} & \textbf{$NRT$}\\
        \hline
        4 & 25000\\
        \hline
        6 & 37500\\
        \hline
        7 & 43750\\
        \hline
        8 & 50000\\
        \hline
        12 & 75000\\
        \hline
        15 & 93750\\
        \hline
        56 & 350000\\
        \hline
        60 & 375000\\
        \hline
    \end{tabular}
    \caption{Number of Relationship Types that will be Generated using Different Route Set Sizes, with a swarm size of 50 and 125 iterations.}
    \begin{itemize}[noitemsep]
    \item[$NRT$:] 50 ($s$) * 125 ($i$) * $NRS$
    \end{itemize} 
    \label{tabel:numberOfRelationshipTypes}
\end{table} 

A third reason is that when calculating the $TOTFIT$ as described in Section \vref{sec:algoEvaluation}, the $F_1(r)$ are emphasized more than both $F_2(r)$ and $F_3(r)$. As described in Section \vref{subsec:evaluating_PerfomanceComparison}, $F_1(r)$ is already favored when running the tests on the Mandl Network, and this results in the best average travel time over all the published methods. However, when the networks becomes significantly larger, such as the ones provided by \citet{mumford13}, the value of $F_1(r)$ becomes much larger than the values of both $F_2(r)$ and $F_3(r)$. This results in that the effect of $F_2(r)$ and $F_3(r)$ boarders against zero. In Table \ref{tabel:averageTotfitAllTestCases} the results of the average $TOTFIT$ is shown for each of the test cases ran. As one can observe the average $TOTFIT$ is much larger for the Mumford0 and Mumford1 cases compared to the Mandl-cases. The reader recalls from Section \vref{sec:totfit}, that the value of $F_2(r)$ is between $-300$ and $0$, and that the value of $F_3(r)$ is between $0$ and $1000$. The value of $F_1(r)$ is dependent on network size and the total demand, and as Table \vref{tabel:averageTotfitAllTestCases} shows dividing $F_1(r)$ on the $nodeSize^2$ is not sufficient enough because $F_1(r)$ becomes too great compared to $F_2(r)$ and $F_3(r)$. \emph{\color{blue} How $F_1(r)$ is calculated was not changed because...}

\begin{table}[H]
    \centering
    \hspace*{-1.0cm}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Number} & \textbf{Instance} & \textbf{Average $TOTFIT$}\\
        \hline
        1 & Mandl (4 routes) & 98.0\\
        \hline
        2 & Mandl (6 routes) & 89.5\\
        \hline
        3 & Mandl (7 routes) & 87.1\\
        \hline
        4 & Mandl (8 routes) & 83.4\\
        \hline
        5 & Mumford0 & 3886.4\\
        \hline
        6 & Mumford1 & 14459.8\\
        \hline
    \end{tabular}
    \caption{Average Total Fitness for All Tests Cases. 1-4 are the results of 50 runs, 5-6 are the results of 10 runs}
    \label{tabel:averageTotfitAllTestCases}
\end{table}
 
The run time for the proposed method is dependent on $NRS$, the number of ants ($s$), the number of iterations ($i$), the size of the network, and whether Method 1 or Method 2 is used. As one can observe from Table \vref{tabel:runTimeMandl} the average run time increases drastically when the number of routes in the Mandl network increases. This may be because $NRT$ in the Neo4j database becomes significantly larger when increasing the number of routes. Which again increase the number of read and writes to the Neo4j database. The run time is also more than 10 times greater using using Method 2 compared to Method 1 as seen in \vref{table:results_mumford0RunTime}. When using Method 1 it is sufficient to use the built in Dijkstra algorithm in Neo4j to only find the shortest path between two nodes given a route set. When Method 2 is used, the proposed method finds all possible routes between two nodes given a route set, and further evaluates which route to choose based on the total travel time (including transfer penalties). The difference in the run time, using Method 1 compared to Method 2, also increases as the network becomes bigger. This is because the algorithm finds a path between every two nodes in the network, and when the network increases, so does (usually) the number of nodes and possible paths as well. Table \vref{tabel:runTimeMumford} shows that the average run times of Mumford0 and Mumford1. It is worth mentioning, that the run times are approximately the same as the ones for the experiments who uses the Mandl Network, even though these experiments have a smaller network and fewer $NRS$, due to the decreased number of $i$ and the fact that Method 1 is used instead of Method 2. 

%Independent of whether it is the route set size, network size, the number of iterations or the number of ants in the colony that becomes bigger, the number of reads and writes to the Neo4j database increases, which again increases the run time. %\emph{\color{blue} Kanskje vi må si noe mer her, finne noe data på hvorfor dette øker run timen eller noe. Kanskje vi må si noe om at vi har observert at minnebruken aldri går over 30\%?}

\begin{table}[H]
    \centering
    \hspace*{-1.0cm}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Instance} & \textbf{Run Time$^1$ (secs)} \\
        \hline
        Mumford0 & 2368.0\\
        \hline
        Mumford1 & 5862.4\\
        \hline
    \end{tabular}
    \caption{Average Runtime in seconds of 10 Runs Using the Mumford Network}
    \label{tabel:runTimeMumford}
    \begin{itemize}[noitemsep]
    \item[$^1$:] $s$ = 50, $i$ = 50
    \end{itemize} 
\end{table}

%\textbf{Did the program demonstrate good performance?}

%\textbf{Is the programs performance different from predictions?}

%\textbf{How efficient is the program?}

%\textbf{Can you define the programs limitations?}
%When does it break, and what components contributes to its successful operations?

%\textbf{Do you understand why it works / doesn't work?}
%What is the impact of changing the program? How does the program respond to the new input? 

%\textbf{Did you learn what you wanted from the programs experiments?}
\subsubsection{From old discussion}


\subsection*{Is it possible to apply the proposed system to optimize urban transit routes in real urban cities?}

The proposed system as-is will not be possible to use for optimizing the urban transit routes in a real urban city. This is because with the current implementation of Neo4j, the system exceeds the address space for the primary key RelationshipType when either the swarm size, the number of iterations or the number of routes in a route set becomes to big compared to the network size. 

As an example consists Trondheim city, which is the forth largest city in Norway, of 33 bus routes \citep{website:atb-linjenett}. If we were to use the current solution, including the selected parameters for the swarm size and iteration number, as described in Section \vref{subsec:parameterSettings_results} the number of relationship types created would be $125 (number of iterations) * 50 (the swarm size) * 33 (bus routes) = 206 250$. The reader recalls from Section \ref{subsec:evalScalability} that the current number of allowed RelationshipTypes in Neo4j is approximately $66 000$.
\emph{\color{blue} Sjekk opp antall bussruter med AtB}.

The system would be applicable to urban cities if the number of generated RelationshipTypes were increased. This can be done by creating the routes as effectively the same RelationshipType, but in order to separate them, add properties, such as ant number and iteration number, to the generated Relationships instead. This solution would, however, lead to not being able to use the built-in shortest path algorithms, such as Dijkstra. This is because they require to choose paths based RelationshipType. Therefore, if one were to change the way different routes were represented in Neo4j, on would also need to implement a separate shortest path algorithm. 

However, even if the number of RelationshipTypes were reduced, there is an other drawback that makes our solution unpractical to use: The large difference in run time between using Method 1 and Method 2 when evaluating the route sets. 
The reader recalls that we in Section \vref{subsec:scalabilityExperiments_setup} indicate that Method 2 gives a better Total Fitness than Method 1, but that the runtime is more than ten times larger compared to using Method 1. These results are also supported by the research of \citet{fan09}. Nevertheless, generating bus routes is an infrequent task in most urban cities and a because of this we believe that a long run time could be acceptable, given that the system creates a better solution than the one that already exists. 

A requirement that must be fulfilled for our system to be applicable is files containing average number of demand between every two nodes/bus stops, travel times between nodes/bus stops and a list of all the nodes/bus stops in the network, similar to the ones provided by \citet{mandl79} and \citet{mumford13}. This data can typically be obtained by the bus companies.

\subsection*{What are the potential advantages and disadvantages of using a graph database in our implementation?}

The graph database Neo4j has several advantages for our implementation. Firstly, Neo4j represent data in a graph way, with nodes and relationship between the nodes. In addition it has the capability of traversing the graph, by following pointers from each node. This corresponds perfectly to our data model, which consist of exclusively objects that can be represented as relationships or nodes. Secondly, it offers an embedded version, which makes it possible to run Neo4j embedded in the Java program. This leads to, as mentioned in {\color{blue} [Skrive inn Section når vi vet hvor dette blir skrevet. Mest sannsynlig i Model]}, a lower latency of the many reads and writes executed when running the algorithm, compared to using a standalone version. Thirdly we do believe the use of Neo4j made our development process smoother and less excessive. This because we were able to benefit from Neo4j features such as the built-in Djikstra algorithm and the possibility to inspect the object graph. Finally, Neo4j is a well-documented and battle-tested graph database system, implemented and used by large companies such as Telenor\cite{website:telenor}, Walmart\cite{website:walmart} and Cisco\cite{website:cisco}. This made it easy for us to retrieve relevant information during the development process and have confidence in the product. 

However, Neo4j also has some disadvantages concerning our implementation. The first one is, as mentioned in Section \vref{subsec:evalScalability}, that the limit of RelationshipTypes is insufficient in our system. This leads to, as mentioned, that we are not able to run the algorithm on larger networks than the Mandl network, without making sacrifices that influence the performance. Secondly, we suspect that the run time of the algorithm would have been improved by removing Neo4j or by least changing the data model. With the current data model, each generated edge in each generated route for each ant for each generated iteration is represented as a relationship {\color{blue} [Vi bør egentlig lage en illustrasjon av datamodellen for å bedre forklare hvordan dataene blir lagret --> Model]}. For the smallest network with the least number of routes tested in this thesis, this still adds up to about 200000 relationships when the swarm size is 50 and the number of iterations is 125. Additionally, by using a database the algorithm executes both read and write operations to disk. It is likely to believe that the run time could have been improved by creating a system using only the Random Access Memory.  

%to find the optimal route between two nodes in a network. It contains a list of all routes between two nodes, and find the most optimal path concerning the cost. A suited query is where you will be looking to find out how different data element are related to each other, finding paths between different nodes on the graph. All you have to do is apply algorithm with start node and end node. (And it can see whether a path exist and finding the optimal path). 

%Neo4j is optimized for multi relational graph, which means graphs with multiple relationship between nodes. It is worth mentioning, that the work relationship is equivalent to an edge. Neo4j comes with different features, including relationship types. Which is added to the relationships and every relationship must have exactly one type - these relationship types is used to traverse a specific query. Neo4j supports complex queries, because it can hop from node to node over its connected relationships. The key performance that follows from this is that performance is independent of the data set size, because in most graphs everything is not connected to everything. Performance will be much more dependent on the size of the result set (How many results a query gives).  \emph{\color{blue} TODO: hvor stort blir resultat settet }

%\textbf{What are the limitations?}\textbf{Do you understand why it work and doesn't work?}
%* Dumb with our solution: we have made a lot of relationship types.
%* However, this results in an enormous amount of relationships and relationship types. Neo4j has a capacity of 1216, which with solution it exceeds when the size of the route sets increase. We experienced, as mentioned over, that Neo4j has a id capacity which is reached when the route sets become greater than 10. This is not very optimal when creating routes in a large transit network. Instead of having a relationship type edge and added properties on these, each individual route for ant for each iteration, receive a relationship type. This makes it possible to separate each individual route for each ant. This makes each route in each route set saved with an unique identifier. A feature that could have been used is the property feature, which can add properties to a relationship. And these properties can be used to evaluate the pattern we are looking for. As stated in \citet{bruggen14}, assigning relationship types between nodes is recommended. This is because the cost of introducing a new relationship between two nodes is very low. Because no additional joins needs to be computed, all that happens is that the graph traversal will use a different path when establishing a course. The use of properties \emph{\color{blue} TODO. undersøke hvordan properties fungerer. evt droppe å nevne det mtp på at sensor mest sanns ikke gidder å lese seg opp på neo4j}

%* [sjekkes opp først] Negative of graph databases: Searching for a specific node, have to search (worst case) trough all nodes. 
%* This also concerns es the relationship types. This is where the bottleneck lies. 

%\textbf{\color{blue} Til diskusjon:}

%The parameters tested and used are specifically tuned for Mandl's Transit Network containing 4 routes, with maximum 8 nodes in one route, but the same parameters are used when testing with 6, 7, and 8 routes as well. This may be considered a weakness, because metaherustic methods, such as the one proposed in this thesis, requires calibration of parameters with respect to the problem at hand \citep{dobslaw09}.

%The proposed method requires input on a particular form. Both nodes and their coordinates, travel time between nodes and the demand between nodes needs to be provided on a particular form in an .txt-document. This may be considered as a weakness of the method, but implementing support for retrieving the mentioned data on another form are considered as fairly easy.

